NOTES: SIMPLIFYING CALIPERIZED LIVE EVENTS DATA

1. BASE COMMAND

Assumes data is in wrapper like this:

  {
    "id": "f8d311fa-3a2f-4a9a-a818-40f2bb428b90",
    "event_type": "NavigationEvent",
    "event_action": "NavigatedTo",
    "event_time": "2018-01-30 12:48:33 UTC",
    "event": {here is all the interesting stuff, as escaped json}
  }

cat <INPUT> | jq -c '.event | fromjson' | jq '.| {event_id:.id,  context_id: .group? | . .extensions? | . ["com.instructure.canvas"]? | . .entity_id?, actor_type: .actor? | . .type?, actor_id:.actor? | . .id?, actor_name: .actor.extensions? | . ["com.instructure.canvas"] | . .user_login?, actor_roles: .membership? | . .roles?, event_action:.action, event_type: .type,  event_time:.eventTime, asset_type: .object.extensions? | . ["com.instructure.canvas"]? | . .asset_type?, asset_entity_id: .object.extensions? | . ["com.instructure.canvas"]? | . .entity_id?, asset_subtype: .object.extensions? | . ["com.instructure.canvas"]? | . .asset_subtype?, context_id_urn:.membership? | . .organization? | .id?, target_id:.object.id}' | jq -s '.' > <OUTPUT>

This one deals with a CLE format that has the following wrapper

  "sensor": "http://umich-dev.instructure.com/",
  "sendTime": "2018-03-08T13:40:34.691Z",
  "dataVersion": "http://purl.imsglobal.org/ctx/caliper/v1p1",
  "data": [ this is where the event data really is, as a list of objects]


cat <INPUT> | jq -c '.data[]' | jq -s '.' > <OUTPUT>

filters below will also work, but instead of selecting the .event and parsing it they need to select the data array:

cat <INPUT> | jq -c '.data[]'

for example - extracting events generated by studenta@umich.edu and sorting them by event time in a simplified and in a native format:

| jq -c '.data[]' | jq '.|select(.actor.extensions? | . ["com.instructure.canvas"] | . .user_login?=="studenta@umich.edu") |  {event_id:.id,  context_id: .group? | . .extensions? | . ["com.instructure.canvas"]? | . .entity_id?, actor_type: .actor? | . .type?, actor_id:.actor? | . .id?, actor_name: .actor.extensions? | . ["com.instructure.canvas"] | . .user_login?, actor_roles: .membership? | . .roles?, event_action:.action, event_type: .type,  event_time:.eventTime, asset_type: .object.extensions? | . ["com.instructure.canvas"]? | . .asset_type?, asset_entity_id: .object.extensions? | . ["com.instructure.canvas"]? | . .entity_id?, asset_subtype: .object.extensions? | . ["com.instructure.canvas"]? | . .asset_subtype?, context_id_urn:.membership? | . .organization? | .id?, target_id:.object.id}' | jq -s 'sort_by(.event_time) |.' > 

| jq -c '.data[]' | jq '.|select(.actor.extensions? | . ["com.instructure.canvas"] | . .user_login?=="studenta@umich.edu")' | jq -s 'sort_by(.eventTime) |.' > lala.json

2. SELECTING A SUBSET

Can select slices with a select as the first piped command after the event object ahs been selected:

select(.actor.extensions? | . ["com.instructure.canvas"] | . .user_login?=="stempel") ()

i.e. - to select events associated with a user

cat <INPUT> | jq -c '.event | fromjson' | jq '.|select(.actor.extensions? | . ["com.instructure.canvas"] | . .user_login?=="stempel") |  {event_id:.id,  context_id: .group? | . .extensions? | . ["com.instructure.canvas"]? | . .entity_id?, actor_type: .actor? | . .type?, actor_id:.actor? | . .id?, actor_name: .actor.extensions? | . ["com.instructure.canvas"] | . .user_login?, actor_roles: .membership? | . .roles?, event_action:.action, event_type: .type,  event_time:.eventTime, asset_type: .object.extensions? | . ["com.instructure.canvas"]? | . .asset_type?, asset_entity_id: .object.extensions? | . ["com.instructure.canvas"]? | . .entity_id?, asset_subtype: .object.extensions? | . ["com.instructure.canvas"]? | . .asset_subtype?, context_id_urn:.membership? | . .organization? | .id?, target_id:.object.id}' | jq -s '.' > <OUTPUT>

i.e. to select a specific type of event, like submitted assignments

cat <INPUT> | jq -c '.event | fromjson' | jq '.|select(.action=="Submitted" and .type=="AssessmentEvent") |  {event_id:.id,  context_id: .group? | . .extensions? | . ["com.instructure.canvas"]? | . .entity_id?, actor_type: .actor? | . .type?, actor_id:.actor? | . .id?, actor_name: .actor.extensions? | . ["com.instructure.canvas"] | . .user_login?, actor_roles: .membership? | . .roles?, event_action:.action, event_type: .type,  event_time:.eventTime, asset_type: .object.extensions? | . ["com.instructure.canvas"]? | . .asset_type?, asset_entity_id: .object.extensions? | . ["com.instructure.canvas"]? | . .entity_id?, asset_subtype: .object.extensions? | . ["com.instructure.canvas"]? | . .asset_subtype?, context_id_urn:.membership? | . .organization? | .id?, target_id:.object.id}' | jq -s '.' > <OUTPUT>

i.e. to select events only in one course, the weird select statement is because the course id is contained in several places depending on the event type.

cat <INPUT> | jq -c '.event | fromjson' | jq '.|select((.membership? | . .id?=="urn:instructure:canvas:course:17700000000207865") or (.group? | . .id?=="urn:instructure:canvas:course:17700000000207865") or (.object? | . .id?=="urn:instructure:canvas:course:17700000000207865")) |  {event_id:.id,  context_id: .group? | . .extensions? | . ["com.instructure.canvas"]? | . .entity_id?, actor_type: .actor? | . .type?, actor_id:.actor? | . .id?, actor_name: .actor.extensions? | . ["com.instructure.canvas"] | . .user_login?, actor_roles: .membership? | . .roles?, event_action:.action, event_type: .type,  event_time:.eventTime, asset_type: .object.extensions? | . ["com.instructure.canvas"]? | . .asset_type?, asset_entity_id: .object.extensions? | . ["com.instructure.canvas"]? | . .entity_id?, asset_subtype: .object.extensions? | . ["com.instructure.canvas"]? | . .asset_subtype?, context_id_urn:.membership? | . .organization? | .id?, target_id:.object.id}' | jq -s '.' > <OUTPUT>

3. SORTING ON A KEY

Add 'sort_by(.KEY_NAME) |.' as the last command to get a chronological list of events (here only the ones associated with a given user)

i.e. this will select all events by user gabastep and sort them by time

cat <INPUT>  | jq -c '.event | fromjson' | jq '.|select(.actor.extensions? | . ["com.instructure.canvas"] | . .user_login?=="gabastep") |  {event_id:.id,  context_id: .group? | . .extensions? | . ["com.instructure.canvas"]? | . .entity_id?, actor_type: .actor? | . .type?, actor_id:.actor? | . .id?, actor_name: .actor.extensions? | . ["com.instructure.canvas"] | . .user_login?, actor_roles: .membership? | . .roles?, event_action:.action, event_type: .type,  event_time:.eventTime, asset_type: .object.extensions? | . ["com.instructure.canvas"]? | . .asset_type?, asset_entity_id: .object.extensions? | . ["com.instructure.canvas"]? | . .entity_id?, asset_subtype: .object.extensions? | . ["com.instructure.canvas"]? | . .asset_subtype?, context_id_urn:.membership? | . .organization? | .id?, target_id:.object.id}' | jq -s 'sort_by(.event_time) |.' > <OUTPUT>

4. BASE COMMAND FOR UNWRAPED DATA

Assumes data is NOT in wrapper:

  {
    "@context": "", "id":"", "type": "", etc
  }
  
cat <INPUT> | jq -c '{event_id:.id,  context_id: .group? | . .extensions? | . ["com.instructure.canvas"]? | . .entity_id?, actor_type: .actor? | . .type?, actor_id:.actor? | . .id?, actor_name: .actor.extensions? | . ["com.instructure.canvas"] | . .user_login?, actor_roles: .membership? | . .roles?, event_action:.action, event_type: .type,  event_time:.eventTime, asset_type: .object.extensions? | . ["com.instructure.canvas"]? | . .asset_type?, asset_entity_id: .object.extensions? | . ["com.instructure.canvas"]? | . .entity_id?, asset_subtype: .object.extensions? | . ["com.instructure.canvas"]? | . .asset_subtype?, context_id:.membership? | . .organization? | .id?, target_id:.object.id}' | jq -s '.' > <OUTPUT>

Functions
---------


function getUser () {
  #getUser canvas-input.jsonl cmhills eventTime output/specific_user.json
  USERNAME=$2
  SORTFIELD=$3
  echo extracting from $1 the records of user $2 and sorting by $3, piping to $4
  cat $1 | jq -c '.event | fromjson' | jq  --arg u "$USERNAME" '.|select(.actor.extensions? | . ["com.instructure.canvas"] | . .user_login?==$u) |  {event_id:.id,  context_id: .group? | . .extensions? | . ["com.instructure.canvas"]? | . .entity_id?, actor_type: .actor? | . .type?, actor_id:.actor? | . .id?, actor_name: .actor.extensions? | . ["com.instructure.canvas"] | . .user_login?, actor_roles: .membership? | . .roles?, event_action:.action, event_type: .type,  event_time:.eventTime, asset_type: .object.extensions? | . ["com.instructure.canvas"]? | . .asset_type?, asset_entity_id: .object.extensions? | . ["com.instructure.canvas"]? | . .entity_id?, asset_subtype: .object.extensions? | . ["com.instructure.canvas"]? | . .asset_subtype?, context_id_urn:.membership? | . .organization? | .id?, target_id:.object.id}' |  jq -s --arg s $SORTFIELD 'sort_by(.[$s]) |.'  > $4
} 

function getClass () {
  #getClass canvas-input.jsonl urn:instructure:canvas:course:17700000000192797 eventTime output/class.json
  CLASSID=$2
  SORTFIELD=$3
  echo extracting from $1 the records of class $CLASSID and sorting by $3, piping to $4
  cat $1 | jq -c '.event | fromjson' | jq --arg c $CLASSID '.|select((.membership? | . .id?==$c) or (.group? | . .id?==$c) or (.object? | . .id?==$c)) |  {event_id:.id,  context_id: .group? | . .extensions? | . ["com.instructure.canvas"]? | . .entity_id?, actor_type: .actor? | . .type?, actor_id:.actor? | . .id?, actor_name: .actor.extensions? | . ["com.instructure.canvas"] | . .user_login?, actor_roles: .membership? | . .roles?, event_action:.action, event_type: .type,  event_time:.eventTime, asset_type: .object.extensions? | . ["com.instructure.canvas"]? | . .asset_type?, asset_entity_id: .object.extensions? | . ["com.instructure.canvas"]? | . .entity_id?, asset_subtype: .object.extensions? | . ["com.instructure.canvas"]? | . .asset_subtype?, context_id_urn:.membership? | . .organization? | .id?, target_id:.object.id}' | jq -s --arg s $SORTFIELD 'sort_by(.[$s]) |.' > $4
} 

function getAction () {
  #getAction canvas-input.jsonl Submitted event_time  output/submitted.json
  ACTION=$2
  SORTFIELD=$3
  echo extracting from $1 the records of action $2, sorting by $3 and piping to $4
  cat $1 | jq -c '.event | fromjson' | jq --arg a $ACTION '.|select(.action==$a) |  {event_id:.id,  context_id: .group? | . .extensions? | . ["com.instructure.canvas"]? | . .entity_id?, actor_type: .actor? | . .type?, actor_id:.actor? | . .id?, actor_name: .actor.extensions? | . ["com.instructure.canvas"] | . .user_login?, actor_roles: .membership? | . .roles?, event_action:.action, event_type: .type,  event_time:.eventTime, asset_type: .object.extensions? | . ["com.instructure.canvas"]? | . .asset_type?, asset_entity_id: .object.extensions? | . ["com.instructure.canvas"]? | . .entity_id?, asset_subtype: .object.extensions? | . ["com.instructure.canvas"]? | . .asset_subtype?, context_id_urn:.membership? | . .organization? | .id?, target_id:.object.id}' |  jq -s --arg s $SORTFIELD 'sort_by(.[$s]) |.' > $4
} 

function getHumanEvents () {
  #getHumanEvents canvas-input.jsonl eventTime output/humans.json
  echo extracting from $1 the records involving human actors; sorting by $2 and piping to $3
  SORTFIELD=$3
  cat $1 | jq -c '.event | fromjson' | jq '.|select(.actor.extensions?) |  {event_id:.id,  context_id: .group? | . .extensions? | . ["com.instructure.canvas"]? | . .entity_id?, actor_type: .actor? | . .type?, actor_id:.actor? | . .id?, actor_name: .actor.extensions? | . ["com.instructure.canvas"] | . .user_login?, actor_roles: .membership? | . .roles?, event_action:.action, event_type: .type,  event_time:.eventTime, asset_type: .object.extensions? | . ["com.instructure.canvas"]? | . .asset_type?, asset_entity_id: .object.extensions? | . ["com.instructure.canvas"]? | . .entity_id?, asset_subtype: .object.extensions? | . ["com.instructure.canvas"]? | . .asset_subtype?, context_id_urn:.membership? | . .organization? | .id?, target_id:.object.id}' |  jq -s --arg s $SORTFIELD 'sort_by(.[$s]) |.' > $3
} 

5. UTILITIES

Parse the JSON object, preserve wrapper - input is a jsonl like above 1.
---------------------------------------
cat <INPUT>.jsonl  | jq -c  '{id: .id, event_type: .event_type, event_action: .event_action, event_time: .event_time, event: .event | fromjson}' | jq -s '.' > <OUTPUT>.json

Find lines with string and show as json - input is a jsonl like above 1. 
---------------------------------------
Useful for finding an event id in the raw data so that you can compare the event in raw data to event in processed/simplified data

grep  '<STRING (like event ID, there will only be one)>' <INPUT>   | jq -c  '{id: .id, event_type: .event_type, event_action: .event_action, event_time: .event_time, event: .event | fromjson}' | jq -s '.' > <OUTPUT>

Sample large raw data - input is a jsonl like above 1.
---------------------
Useful of data is too large, want to experiment with a random subset.

shuf -n NNNNNNNN <INPUT> <OUTPUT>

where NNNNNNN is the number of lines you want to randomly sample from.

Count events with string matching
---------------------------------

grep -o '<STRING>' <INPUT> | wc -l

ODDITIES
========

Some events list an asset_type (.object.extensions? | . ["com.instructure.canvas"]? | . .asset_type?) that is also reflected in the .object.id

ie

    "asset_type": "discussion_topic",
    "object_id": "urn:instructure:canvas:discussion:17700000000437223"

others not

    "asset_type": null,
    "object_id": "urn:instructure:canvas:submission:17700000022998464"

there is no 1-1 correspondence ("discussion_topic" vs "discussion" above)

and sometimes the object.id is reflected in the event_action

    "event_action": "Submitted",
    "event_type": "AssessmentEvent",
    "object_id": "urn:instructure:canvas:submission:17700000001577052"

